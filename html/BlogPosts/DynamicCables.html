<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Blogs | Dynamic Cables</title>
    <link rel="stylesheet" href="../../css/style.css">
    <link rel="stylesheet" href="../../css/effects.css">
    <link rel="stylesheet" href="../../css/imageSlider.css">
    <link rel="stylesheet" href="../../css/Blog.css">
</head>
<body>
<nav class="">
    <!--  made-up logo  -->
    <a href="../index.html" id="main-logo">
        <p class="logo">H</p>
        <div class="rectangle"></div>
        <p class="logo">ME</p>
    </a>

    <div class="navLinks">
        <div class="dropdown">
            <a href="../Games.html" class="navbar navbarButton">Games</a>
            <div class="hidden">
                <a href="../Mik.html" class="navbar navSublinks">Mik</a>
                <a href="../ThreeToOne.html" class="navbar navSublinks">Three To One</a>
                <a href="../DeliverDeezNuts.html" class="navbar navSublinks">Deliver Deez Nuts</a>
            </div>
        </div>
        <a href="../Blog.html" class="navbar navbarButton">Blog</a>
    </div>

</nav>

<div class="column posts">
    <div class="blogPost">
        <a href="https://twitter.com/Stefaaan06" class="moreInfo" target="_blank">@Stefaaan06 - 18-08-2023</a>
        <h2>Dynamic cables in Unity 3D</h2>

        <p> <i>Heya!</i>  <br>
            In this Tutorial post I´ll explain the process of creating my dynamic Cable system, which is still not that CPU heavy, in unity.
            <br>
            <br>
        </p>
        <h3>Step 1: Cable Physics</h3>
        <p>
            As a start i created 4 Objects with Rigidbodies on them (more rigidbodies = more CPU calculation) with one of them being Kinematic and not using Gravity.
            The other 3 all receive an Configurable joint element for which you <i>all</i> configure the Connected body to be the <i>Kinematic Rigidbody</i>, I´ll explain why later. <br>
            You can play around & modify the values to your likings but i used the following configuration:
        </p>
        <img src="../../img/blogImg1.png" alt="BlogImage1">
        <p>On top of that i changed the Position Spring & Position Dampener (limits the amount that the object can stretch from the connected body) to be higher on the (physically) lower objects so the cables dont stretch too far. <br>
            After that I added a Spring Joint to the last 2 (if you use more than 4 Rigidbodies, add them to all except the not moving one and the one directly below it). Connect these with the Objects above the current one.
            <br>
            This is the configuration I used:
        </p>
        <img src="../../img/blogImg2.png" alt="BlogImage2">
        <p>Once again I changed the "Spring" and "Damper" values for the 2 Objects to get a more realistic effect.
            <br>
            <br>
            To better visualize this: this is an image representing the Joint connections. Red lines are the Configurable Joint connections. They all lead to the not moving Rigidbody, they keep the Rigidbodies in place.
            The blue lines represent the Spring Joing connections, they add more realistic phyics to the lower Rigidbodies.
        </p>
        <img src="../../img/blogImg3.png" alt="BlogImage2">

        <h3>Step 1: Rendering the Cable</h3>
        <p>If you got this far, you can add colliders to the objects and see that the Lines are indeed moving, but there is no cable being rendered. For this I added a Line Renderer to the Kinematic Object and used this simple script to update the Line every Frame:</p>
        <p class="code">
            using System; <br>
            using System.Collections; <br>
            using System.Collections.Generic; <br>
            using UnityEngine; <br>
            <br>
            public class lightBulbCable : MonoBehaviour <br>
            { <br>
                public GameObject[] objs; <br>
                public LineRenderer lineRenderer; <br>
                <br>
                private void Update() <br>
                { <br>
                    for (int i = 0; i < objs.Length; i++) <br>
                    { <br>
                        lineRenderer.SetPosition(i, objs[i].transform.position); <br>
                    } <br>
                <br>
                } <br>
            } <br>
        </p>
        <p>
            After that you just have to assign all the Objects to the Array as well as the Line Renderer to the Line Renderer and set the Position size of the Line Renderer to the amount of RBs your cable is made of<br>
            If nothing went wrong, you should see a simple Line being rendered between the objects.
        </p>
        <h3>Step 3: Smoothing out the lines</h3>
        <p>If the current result is all you need, you can stop now, but if you want smoother lines, you can use these Scripts:
        <br>
        Script 1
        </p>
        <p class="code">
            using System;<br>
            using System.Collections;<br>
            using System.Collections.Generic;<br>
            using UnityEngine;<br><br>
            public class runtimeSmoothing : MonoBehaviour<br>
            {<br>
            public LineRenderer Line;<br>
            public float SmoothingLength = 2f;<br>
            public int SmoothingSections = 10;<br><br>
            public BezierCurve[] Curves;<br><br>
            private void Start()<br>
            {<br>
            EnsureCurvesMatchLineRendererPositions();<br>
            calculateCurves();<br>
            SmoothPath();<br>
            }<br><br>
            void LateUpdate()<br>
            {<br>
            calculateCurves();<br>
            SmoothPath();<br>
            }<br><br>
            void calculateCurves()<br>
            {<br>
            for (int i = 0; i < Curves.Length; i++)<br>
            {<br>
            Vector3 position = Line.GetPosition(i);<br>
            Vector3 lastPosition = i == 0 ? Line.GetPosition(0) : Line.GetPosition(i - 1);<br>
            Vector3 nextPosition = Line.GetPosition(i + 1);<br><br>
            Vector3 lastDirection = (position - lastPosition).normalized;<br>
            Vector3 nextDirection = (nextPosition - position).normalized;<br><br>
            Vector3 startTangent = (lastDirection + nextDirection) * SmoothingLength;<br>
            Vector3 endTangent = (nextDirection + lastDirection) * (-1 * SmoothingLength);<br><br>
            Curves[i].Points[0] = position;<br>
            Curves[i].Points[1] = position + startTangent;<br>
            Curves[i].Points[2] = nextPosition + endTangent;<br>
            Curves[i].Points[3] = nextPosition;<br>
            }<br><br>
            {<br>
            Vector3 nextDirection = (Curves[1].EndPosition - Curves[1].StartPosition).normalized;<br>
            Vector3 lastDirection = (Curves[0].EndPosition - Curves[0].StartPosition).normalized;<br><br>
            Curves[0].Points[2] = Curves[0].Points[3] +<br>
            (nextDirection + lastDirection) * (-1 * SmoothingLength);<br>
            }<br>
            }<br><br>
            private void SmoothPath()<br>
            {<br>
            Line.positionCount = Curves.Length * SmoothingSections;<br>
            int index = 0;<br>
            for (int i = 0; i < Curves.Length; i++)<br>
            {<br>
            Vector3[] segments = Curves[i].GetSegments(SmoothingSections);<br>
            for (int j = 0; j < segments.Length; j++)<br>
            {<br>
            Line.SetPosition(index, segments[j]);<br>
            index++;<br>
            }<br>
            }<br>
            }<br><br>
            private void EnsureCurvesMatchLineRendererPositions()<br>
            {<br>
            if (Curves == null || Curves.Length != Line.positionCount - 1)<br>
            {<br>
            Curves = new BezierCurve[Line.positionCount - 1];<br>
            for (int i = 0; i < Curves.Length; i++)<br>
            {<br>
            Curves[i] = new BezierCurve();<br>
            }<br>
            }<br>
            }<br>
            }
        </p>
        <p>
            Script 2
        </p>
        <p class="code">
            using UnityEngine;<br><br>
            [System.Serializable]<br>
            public class BezierCurve<br>
            {<br>
            public Vector3[] Points;<br><br>
            private BezierCurve()<br>
            {<br>
            Points = new Vector3[4];<br>
            }<br><br>
            public BezierCurve(Vector3[] Points)<br>
            {<br>
            this.Points = Points;<br>
            }<br><br>
            public Vector3 StartPosition<br>
            {<br>
            get<br>
            {<br>
            return Points[0];<br>
            }<br>
            }<br><br>
            public Vector3 EndPosition<br>
            {<br>
            get<br>
            {<br>
            return Points[3];<br>
            }<br>
            }<br><br>
            // Equations from: https://en.wikipedia.org/wiki/B%C3%A9zier_curve<br>
            public Vector3 GetSegment(float Time)<br>
            {<br>
            Time = Mathf.Clamp01(Time);<br>
            float time = 1 - Time;<br>
            return (time * time * time * Points[0])<br>
            + (3 * time * time * Time * Points[1])<br>
            + (3 * time * Time * Time * Points[2])<br>
            + (Time * Time * Time * Points[3]);<br>
            }<br><br>
            public Vector3[] GetSegments(int Subdivisions)<br>
            {<br>
            Vector3[] segments = new Vector3[Subdivisions];<br><br>
            float time;<br>
            for (int i = 0; i < Subdivisions; i++)<br>
            {<br>
            time = (float)i / Subdivisions;<br>
            segments[i] = GetSegment(time);<br>
            }<br><br>
            return segments;<br>
            }<br>
            }
        </p>

        <p>
            If you want to understand how these work, then watch this Video which I stole the stuff from: https://www.youtube.com/watch?v=u0yZb1xIyLA <br>
            Basically it calculates additional points to the Line using bezier Curves. To use this, you just have to assign the "Runtime Smoothing" Script to an object,
            , then assign the Line to the LineRenderer component and configure the Variables. Smoothing Length controls how far off the points can be, Smoothing Sections controls the amount
            of points added per already existing point.
        </p>
        <a href="../Blog.html" class="blogButton">All Blogs</a>
    </div>
</div>


<div id="part3" class="flex column">
    <a href="https://twitter.com/Stefaaan06" class="moreInfo" target="_blank">By @Stefaaan06 - 2023</a>
</div>
</body>
</html>